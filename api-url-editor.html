<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../paper-input/paper-input-container.html">
<link rel="import" href="../paper-input/paper-input-behavior.html">
<link rel="import" href="../paper-input/paper-input-error.html">
<link rel="import" href="../iron-validatable-behavior/iron-validatable-behavior.html">
<link rel="import" href="../iron-input/iron-input.html">
<link rel="import" href="../events-target-behavior/events-target-behavior.html">
<dom-module id="api-url-editor">
  <template>
    <style include="markdown-styles"></style>
    <style>
    :host {
      outline: none;
      display: block;
      @apply --api-url-editor;
    }

    input {
      @apply --paper-input-container-shared-input-style;
      @apply --paper-input-container-input-input-style;
    }

    label {
      pointer-events: none;
    }

    .markdown-body * {
      font-size: 13px !important;
    }

    .markdown-body p:first-child {
      margin-top: 0;
      padding-top: 0;
    }

    .markdown-body p:last-child {
      margin-bottom: 0;
      padding-bottom: 0;
    }
    </style>
    <paper-input-container
      no-label-float="[[noLabelFloat]]"
      always-float-label="[[alwaysFloatLabel]]"
      auto-validate$="[[autoValidate]]"
      disabled$="[[disabled]]"
      invalid="[[invalid]]">
      <label hidden$="[[!label]]" slot="label">[[label]]</label>
      <iron-input
        id$="[[_inputId]]"
        bind-value="{{value}}"
        slot="input"
        invalid="{{invalid}}">
        <input
          aria-labelledby$="[[_ariaLabelledBy]]"
          aria-describedby$="[[_ariaDescribedBy]]"
          disabled$="[[disabled]]"
          title$="[[title]]"
          type="url"
          required$="[[required]]"
          autocomplete$="[[autocomplete]]"
          autofocus$="[[autofocus]]"
          inputmode$="[[inputmode]]"
          name$="[[name]]"
          placeholder$="[[placeholder]]"
          readonly$="[[readonly]]"
          list$="[[list]]"
          autocapitalize$="[[autocapitalize]]"
          autocorrect$="[[autocorrect]]"
          on-change="_onChange"
          on-blur="_onElementBlur"
          on-input="__userInputHandler"
          tabindex$="[[tabIndex]]"
          autosave$="[[autosave]]">
      </iron-input>
      <template is="dom-if" if="[[invalid]]">
        <paper-input-error slot="add-on" invalid>[[errorMessage]]</paper-input-error>
      </template>
    </paper-input-container>
  </template>
  <script>
  const _inputBehavior2 = !(Polymer.PaperInputBehavior instanceof Array);
  const _behaviorsQueue = [];
  let _base = ArcBehaviors.EventsTargetBehavior(Polymer.Element);
  if (_inputBehavior2) {
    // API console with Anypoint styling has its own implementation of
    // paper input behavior which is for Polymer 2 only.
    _base = Polymer.PaperInputBehavior(_base);
  } else {
    _behaviorsQueue.push(Polymer.PaperInputBehavior);
  }
  if (!Polymer.IronValidatableMixin) {
    _behaviorsQueue.push(Polymer.IronValidatableBehavior);
  } else {
    _base = Polymer.IronValidatableMixin(_base);
  }
  _base = Polymer.mixinBehaviors(_behaviorsQueue, _base);
  /**
   * `api-url-editor`
   * An AMF powered url editor for the HTTP request editor.
   *
   * The element is regular input element that is adjusted to work with URL
   * data.
   * It supports validation for URL values that may contain variables.
   *
   * @customElement
   * @polymer
   * @demo demo/index.html
   * @appliesMixin Polymer.PaperInputBehavior
   * @appliesMixin Polymer.IronValidatableBehavior
   * @appliesMixin ArcBehaviors.EventsTargetBehavior
   * @memberof ApiElements
   */
  class ApiUrlEditor extends _base {
    static get is() { return 'api-url-editor';}
    static get properties() {
      return {
        /**
         * The label for this input.
         */
        label: {
          type: String,
          value: 'Request URL'
        },
        // A value generated by this editor - the URL.
        value: {
          type: String,
          notify: true,
          observer: '_onValueChanged'
        },
        // An error message to display
        errorMessage: {
          type: String,
          value: 'Fill the URI parameters before making a request'
        },
        /**
         * Value or RAML's base URI property.
         *
         * Note, the element doesn't check if `baseUri` is relative or not.
         * Hosting application have to take care of that.
         */
        baseUri: String,
        /**
         * Currently selected endpoint relative URI.
         * It is available in RAML definition.
         */
        endpointPath: String,
        // Computed value, sum of `baseUri` and `endpointPath`
        _fullUri: {
          computed: '_computeFullUrl(baseUri, endpointPath)'
        },
        /**
         * Computed query properties model.
         * Use `api-url-data-model` to compute model for the view.
         */
        queryModel: {
          type: Array,
          notify: true
        },
        /**
         * Computed URI properties model.
         * Use `api-url-data-model` to compute model for the view.
         */
        pathModel: {
          type: Array,
          notify: true
        },
        /**
         * Computed, ordered list of URL variables in the URI string.
         */
        urlParams: {
          type: Array,
          computed: '_computeUrlParams(_fullUri)'
        },
        /**
         * Computed regexp for the current `_fullUri` value to search for the
         * URI parameters.
         */
        urlSearchRegexp: {
          type: RegExp,
          computed: '_computeUrlRegexp(_fullUri)'
        }
      };
    }

    static get observers() {
      return [
        '_computeValueChanged(_fullUri, queryModel.*, pathModel.*)'
      ];
    }

    constructor() {
      super();
      this._extValueChangedHandler = this._extValueChangedHandler.bind(this);
    }

    ready() {
      super.ready();
      this._elementReady = true;
      // If there's an initial input, validate it.
      if (this.value) {
        this._handleAutoValidate();
      }
    }

    _attachListeners(node) {
      node.addEventListener('url-value-changed', this._extValueChangedHandler);
    }

    _detachListeners(node) {
      node.removeEventListener('url-value-changed', this._extValueChangedHandler);
    }

    /**
     * Computes endpoint's full URI with (possibly) variables in it.
     *
     * @param {String} baseUri API base URI
     * @param {String} endpointPath Endpoint relative URI to `baseUri`
     * @return {String} A full URI for the endpoint.
     */
    _computeFullUrl(baseUri, endpointPath) {
      if (!endpointPath) {
        endpointPath = '/';
      }
      if (endpointPath[0] !== '/') {
        endpointPath = '/' + endpointPath;
      }
      if (!baseUri) {
        return endpointPath;
      }
      if (baseUri[baseUri.length - 1] === '/') {
        baseUri = baseUri.substr(0, baseUri.length - 1);
      }
      return baseUri + endpointPath;
    }

    _computeValueChanged(_fullUri, queryRecord, uriRecord) {
      if (this.__ignoreValueChange) {
        return;
      }
      this._computeValue(queryRecord.base, uriRecord.base, _fullUri);
    }
    /**
     * Computes url value from current `baseUri` and query/uri models.
     *
     * @param {Array} queryModel Query parameters model
     * @param {Array} pathModel Uri parameters model.
     * @param {String} uri Current endpoint uri.
     */
    _computeValue(queryModel, pathModel, uri) {
      if (!uri) {
        this.set('value', undefined);
        return;
      }
      uri = this._applyUriParams(uri, pathModel);
      uri = this._applyQueryParams(uri, queryModel);
      this.set('value', uri);
    }
    /**
     * Creates a map of serialized values from a model.
     * It is a replacemenet for `iron-form` serialize function which
     * can't be used here because this function is called before local DOM
     * is ready and therefore form is not set.
     *
     * @param {Array} model Model to compute.
     * @return {Map} Map of serialized values.
     */
    _formValuesFromModel(model) {
      const result = new Map();
      if (!model || !model.length) {
        return result;
      }
      model.forEach((item) => {
        const value = this._valueFormModelItem(item);
        if (value !== undefined) {
          result.set(item.name, value);
        }
      });
      return result;
    }
    /**
     * Extracts value from the model item.
     * If the item is required it is alwats returned (even  if it is empty string).
     * If value is not required and not present then it returns `undefined`.
     *
     * @param {Object} item Model item
     * @return {String} Model value
     */
    _valueFormModelItem(item) {
      if (item.schema && item.schema.enabled === false) {
        return;
      }
      let value = item.value;
      if (!value && item.required) {
        if (value !== 0 && value !== false && value !== null) {
          value = '';
        }
      } else if (!item.required) {
        if (!value && value !== 0 && value !== false && value !== null) {
          value = undefined;
        }
      }
      return value;
    }
    /**
     * Applies URI parameters to the URL.
     *
     * @param {String} url An URL to apply the params to
     * @param {Array} model Uri parameters model.
     * @return {String} The URL.
     */
    _applyUriParams(url, model) {
      if (!model) {
        return url;
      }
      const uriParams = this._formValuesFromModel(model);
      for (let [name, value] of uriParams) {
        if (!value) {
          continue;
        }
        value = String(value);
        if (value.trim() === '') {
          continue;
        }
        value = this._wwwFormUrlEncodePiece(value);
        const re = new RegExp('{' + name + '}');
        url = url.replace(re, value);
      }
      return url;
    }
    /**
     * Applies query parameters to the URL.
     * Query parameters that are not required by the API spec and don't have value
     * are removed from the URL. Parameters that are required and don't have
     * value are set to the URL but with empty value.
     *
     * @param {String} url An URL to apply the params to
     * @param {Array} model Query parameters model.
     * @return {String} The URL.
     */
    _applyQueryParams(url, model) {
      if (!model) {
        return url;
      }
      let params = this._formValuesFromModel(model);
      const items = this._computeQueryItems(params);
      params = this._wwwFormUrlEncode(items);
      if (!params) {
        return url;
      }
      url += (url.indexOf('?') === -1) ? '?' : '&';
      url += params;
      return url;
    }
    /**
     * Computes query parameters list of items containing `name` and `value`
     * properties to use to build query string.
     *
     * This function may change the `params` map.
     *
     * @param {Object} params Map of query model properties.
     * @return {Array} List of query parameters.
     */
    _computeQueryItems(params) {
      const items = [];
      for (let [name, value] of params) {
        if (value === undefined) {
          continue;
        }
        let isArray = false;
        if (value instanceof Array) {
          isArray = true;
          if (!value.length || (value.length === 1 && !value[0])) {
            continue;
          }
        }
        if (isArray) {
          for (let i = 0, len = value.length; i < len; i++) {
            if (value || value === 0 || value === false) {
              items.push({
                name: name,
                value: value[i]
              });
            }
          }
        } else {
          items.push({
            name: name,
            value: value
          });
        }
      }
      return items;
    }
    /**
     * @param {Array} object The list of objects to encode as
     * x-www-form-urlencoded string. Each entry should have `name` and `value`
     * properties.
     * @return {string} .
     */
    _wwwFormUrlEncode(object) {
      if (!object || !object.length) {
        return '';
      }
      const pieces = object.map((item) => {
        return this._wwwFormUrlEncodePiece(item.name) + '=' +
          this._wwwFormUrlEncodePiece(item.value);
      });
      return pieces.join('&');
    }
    /**
     * @param {*} str A key or value to encode as x-www-form-urlencoded.
     * @return {string} .
     */
    _wwwFormUrlEncodePiece(str) {
      // Spec says to normalize newlines to \r\n and replace %20 spaces with +.
      // jQuery does this as well, so this is likely to be widely compatible.
      if (!str) {
        return '';
      }
      return encodeURIComponent(str.toString()
        .replace(/\r?\n/g, '\r\n'))
        .replace(/%20/g, '+');
    }
    /**
     * Updates URI / query parameters model from user input.
     *
     * @param {Event} e Input event
     */
    __userInputHandler(e) {
      const value = e.target.value;
      let matches;
      const uriParams = this.urlParams;
      const uriRegexp = this.urlSearchRegexp;
      if (uriParams && uriRegexp) {
        matches = value.match(uriRegexp);
        if (matches) {
          matches.shift();
          this._applyUriValues(matches, uriParams);
        }
      }
      const matchesNew = value.match(/[^&?]*?=[^&?]*/g);
      if (!matchesNew) {
        return;
      }
      const params = {};
      matchesNew.forEach((item) => this._applyQueryParamToObject(item, params));
      this._applyQueryParamsValues(params);
    }
    /**
     * Applies query parameter values to an object.
     * Repeated parameters will have array value intead of string value.
     *
     * @param {String} param Query parameter value as string. Eg `name=value`
     * @param {Object} obj Target for values
     */
    _applyQueryParamToObject(param, obj) {
      if (!param || !obj || typeof param !== 'string') {
        return;
      }
      const parts = param.split('=');
      const name = parts[0];
      if (name in obj) {
        if (!(obj[name] instanceof Array)) {
          obj[name] = [obj[name]];
        }
        obj[name].push(parts[1]);
      } else {
        obj[name] = parts[1];
      }
    }
    /**
     * Applies values from the `values` array to the uri parametes which names are in the `names`
     * array.
     * Both lists are ordered list of paramerters.
     *
     * @param {Array<String>} values Values for the parameters
     * @param {Array<String>} names List of variables names (uri parameters).
     */
    _applyUriValues(values, names) {
      for (let i = 0, len = names.length; i < len; i++) {
        const name = names[i];
        const index = this._findModelIndex(name, 'path');
        if (index !== -1) {
          this.__ignoreValueChange = true;
          this.set(['pathModel', index, 'value'], values[i]);
          this.__ignoreValueChange = false;
        }
      }
    }
    /**
     * Applies query parameters values to the render list.
     *
     * @param {Object} map A map where keys are names of the parameters in the
     * `queryModel` list
     */
    _applyQueryParamsValues(map) {
      for (let name in map) {
        const index = this._findModelIndex(name, 'query');
        if (index !== -1) {
          this.__ignoreValueChange = true;
          this.set(['queryModel', index, 'value'], map[name]);
          this.__ignoreValueChange = false;
        }
      }
    }

    _findModelIndex(name, type) {
      const model = this[type + 'Model'];
      if (!model) {
        return -1;
      }
      return model.findIndex((item) => item.name === name);
    }
    /**
     * A handler that is called on input
     */
    _onValueChanged() {
      if (!this._elementReady || this.__cancelValueChange) {
        return;
      }
      this.fire('url-value-changed', {
        value: this.value
      });
      this._handleAutoValidate();
    }

    _onElementBlur() {
      this._handleAutoValidate();
    }
    /**
     * A handler for the `url-value-changed` event.
     * If this element is not the source of the event then it will update the `value` property.
     * It's to be used besides the Polymer's data binding system.
     */
    _extValueChangedHandler(e) {
      if (e.target === e.composedPath()[0]) {
        return;
      }
      this.__cancelValueChange = true;
      this.set('value', e.detail.value);
      this.__cancelValueChange = false;
    }

    _getValidity() {
      const value = this.value;
      if (!this.required && !value) {
        return true;
      }
      if (value === undefined) {
        return true;
      }
      if (!value && this.required) {
        return false;
      }
      if (!value) {
        return true;
      }
      if (value.indexOf('{') !== -1 && value.indexOf('}') !== -1) {
        return false;
      }
      if (!this.shadowRoot) {
        return true;
      }
      return this.shadowRoot.querySelector('input').validity.valid;
    }
    /**
     * Creates a regular expression from the `_fullUri` to match the
     * parameters in the `value` url.
     *
     * @param {String} url Enpoint's absolute URL with (possibly) parameters.
     * @return {String} A RegExp that can be used to search for parameters values.
     */
    _computeUrlRegexp(url) {
      if (!url) {
        return null;
      }
      url = url.replace(/(\.|\/)/g, '\\$1');
      url = url.replace(/{\w+}/g, '([a-zA-Z0-9\\$\\-_\\.~\\+!\'\\(\\)\\*]+)');
      return new RegExp(url);
    }
    /**
     * Computes ordered list of parameters applied to the `_fullUri`.
     * For example the URL: `http://{environment}.domain.com/{apiVersion}/`
     *
     * will be mapped to
     * ```
     * [
     *   "environment",
     *   "apiVersion"
     * ]
     * ```
     *
     * @param {String} url The URL to test for the parameters.
     * @return {Array|null} An ordered list of parameters or null if none found.
     */
    _computeUrlParams(url) {
      if (!url) {
        return null;
      }
      let paramsNames = url.match(/\{\w+\}/g);
      if (paramsNames) {
        paramsNames = paramsNames.map((item) => item.substr(1, item.length - 2));
      }
      return paramsNames;
    }

    fire(type, detail, options) {
      const defaults = {
        bubbles: true,
        composed: true,
        cancelable: false
      };
      if (!options) {
        options = defaults;
      } else {
        options = Object.assign(defaults, options);
      }
      options.detail = detail;
      const e = new CustomEvent(type, options);
      this.dispatchEvent(e);
      return e;
    }
  }

  window.customElements.define(ApiUrlEditor.is, ApiUrlEditor);
  </script>
</dom-module>
