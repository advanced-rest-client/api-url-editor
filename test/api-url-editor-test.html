<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">
    <title>api-url-editor test</title>
    <script src="../../../@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../../wct-browser-legacy/browser.js"></script>
  </head>
  <body>

    <test-fixture id="Basic">
      <template>
        <api-url-editor></api-url-editor>
      </template>
    </test-fixture>

    <script type="module">
    import '../api-url-editor.js';
    /* global sinon */
    const BASE_URI = 'https://{base}.domain.com';
    suite('Basic computations', () => {
      let element;
      const TEST_PATH = '/test/{path}/value/{param}';
      suiteSetup(() => {
        element = fixture('Basic');
        element.baseUri = BASE_URI;
        element.endpointPath = TEST_PATH;
      });

      test('Computes _fullUrl', () => {
        assert.equal(element._fullUri, BASE_URI + TEST_PATH);
      });

      test('urlParams is computed', () => {
        assert.typeOf(element.urlParams, 'array');
        assert.lengthOf(element.urlParams, 3);
      });

      test('urlParams contains all path parameters', () => {
        assert.equal(element.urlParams[0], 'base');
        assert.equal(element.urlParams[1], 'path');
        assert.equal(element.urlParams[2], 'param');
      });

      test('urlSearchRegexp is computed', () => {
        assert.ok(element.urlSearchRegexp);
      });
    });

    suite('Array values', () => {
      let element;
      let querylModel;
      const TEST_PATH = '/path/{var}';
      setup(() => {
        element = fixture('Basic');
        element.baseUri = BASE_URI;
        element.endpointPath = TEST_PATH;
        querylModel = [{
          value: 'test',
          name: 'test',
          required: true,
          schema: {}
        }, {
          value: ['test'],
          name: 'arrayParameter',
          required: true,
          schema: {}
        }];
      });

      test('Produces URL with single array value', () => {
        element.set('queryModel', querylModel);
        const match = element.value.match(/&arrayParameter=/g);
        assert.equal(match.length, 1);
      });

      test('Element produces URL with array values', () => {
        querylModel[1].value.push('test2');
        element.set('queryModel', querylModel);
        const match = element.value.match(/&arrayParameter=/g);
        assert.equal(match.length, 2);
      });
    });

    suite('Dispatches events', () => {
      let element;
      let querylModel;
      const TEST_PATH = '/path/{var}';
      setup(() => {
        element = fixture('Basic');
        element.baseUri = BASE_URI;
        element.endpointPath = TEST_PATH;
        querylModel = [{
          value: 'test',
          name: 'value',
          required: true,
          schema: {}
        }];
      });

      test('Dispatches url-value-changed custom event', () => {
        const spy = sinon.stub();
        element.addEventListener('url-value-changed', spy);
        element.value = URL;
        assert.isTrue(spy.calledOnce);
      });

      test('Dispatches url-value-changed event when query parameter change', () => {
        const spy = sinon.stub();
        element.addEventListener('url-value-changed', spy);
        element.set('queryModel', querylModel);
        assert.isTrue(spy.calledOnce);
      });

      test('Event contains declared properties', (done) => {
        element.addEventListener('url-value-changed', (e) => {
          assert.equal(e.detail.value, 'https://{base}.domain.com/path/{var}?value=test');
          done();
        });
        element.set('queryModel', querylModel);
      });
    });

    suite('Handles events', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      function fire(url) {
        document.body.dispatchEvent(new CustomEvent('url-value-changed', {
          bubbles: true,
          detail: {
            value: url
          }
        }));
      }

      test('Updates value from the event', () => {
        const url = 'https://domain.com/';
        fire(url);
        assert.equal(element.value, url);
      });

      test('Does not redispatch the event', () => {
        const url = 'https://domain.com/path';
        const spy = sinon.stub();
        element.addEventListener('url-value-changed', spy);
        fire(url);
        assert.isFalse(spy.called);
      });
    });

    suite('URL templates', () => {
      let element;
      let pathlModel;
      const TEST_PATH = '/path/{+var}';
      setup(() => {
        element = fixture('Basic');
        element.baseUri = BASE_URI;
        element.endpointPath = TEST_PATH;
        pathlModel = {
          value: '/test and extra!',
          name: '+var',
          required: true,
          schema: {}
        };
      });

      test('Processes URL template with plus sign', () => {
        const item = Object.assign({}, pathlModel);
        item.value = 'test';
        const model = [item];
        element.set('pathModel', model);
        assert.equal(element.value, 'https://{base}.domain.com/path/test');
      });

      test('Encodes special characters', () => {
        const item = Object.assign({}, pathlModel);
        item.value = 'test and extra';
        const model = [item];
        element.set('pathModel', model);
        assert.equal(element.value, 'https://{base}.domain.com/path/test%20and%20extra');
      });

      test('Does not encode reserved characters', () => {
        const item = Object.assign({}, pathlModel);
        item.value = '/test and extra!';
        const model = [item];
        element.set('pathModel', model);
        assert.equal(element.value, 'https://{base}.domain.com/path//test%20and%20extra!');
      });
    });

    suite('_computeUrlParams()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Returns null when no argument', () => {
        const result = element._computeUrlParams();
        assert.equal(result, null);
      });

      test('Retuns parameter names', () => {
        const result = element._computeUrlParams('/{paramA}/{paramB}');
        assert.deepEqual(result, ['paramA', 'paramB']);
      });

      test('Retuns null when no parameters', () => {
        const result = element._computeUrlParams('/paramA/paramB');
        assert.equal(result, null);
      });
    });

    suite('fire()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      const eventName = 'test-event';
      const eventDetail = {type: 'test-detail'};

      test('Dispatches the event', () => {
        const spy = sinon.spy();
        element.addEventListener(eventName, spy);
        element.fire(eventName, eventDetail);
        assert.isTrue(spy.called);
      });

      test('Returns the event', () => {
        const e = element.fire(eventName, eventDetail);
        assert.typeOf(e, 'customevent');
        assert.equal(e.type, eventName);
      });

      test('Event has detail', () => {
        const e = element.fire(eventName, eventDetail);
        assert.deepEqual(e.detail, eventDetail);
      });

      test('Event is cancelable', () => {
        const e = element.fire(eventName, eventDetail);
        assert.isFalse(e.cancelable);
      });

      test('Event bubbles', () => {
        const e = element.fire(eventName, eventDetail);
        assert.isTrue(e.bubbles);
      });
    });

    suite('_computeUrlRegexp()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Returns null when no argument', () => {
        const result = element._computeUrlRegexp();
        assert.equal(result, null);
      });

      test('Returns RegExp', () => {
        const result = element._computeUrlRegexp('https://domain.com/api');
        assert.typeOf(result, 'regexp');
      });

      test('Escapes special caracters', () => {
        const result = element._computeUrlRegexp('https://domain.com/api');
        assert.equal(result.source, 'https:\\/\\/domain\\.com\\/api');
      });

      test('Escapes variables', () => {
        const result = element._computeUrlRegexp('/{paramA}/paramB');
        assert.equal(result.source, '\\/([a-zA-Z0-9\\$\\-_\\.~\\+!\'\\(\\)\\*]+)\\/paramB');
      });
    });

    suite('_onElementBlur()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Calls _handleAutoValidate()', () => {
        const spy = sinon.spy(element, '_handleAutoValidate');
        element._onElementBlur();
        assert.isTrue(spy.called);
      });
    });

    suite('_findModelIndex()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Returns -1 when no model', () => {
        const result = element._findModelIndex('query', 'test');
        assert.equal(result, -1);
      });

      test('Returns index in model', () => {
        element.queryModel = [{name: 't1'}, {name: 't2'}];
        const result = element._findModelIndex('t2', 'query');
        assert.equal(result, 1);
      });

      test('Returns -1 when item do not exists', () => {
        element.queryModel = [{name: 't1'}, {name: 't2'}];
        const result = element._findModelIndex('t3', 'query');
        assert.equal(result, -1);
      });
    });

    suite('_applyQueryParamsValues()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Does nothing when no argument', () => {
        element._applyQueryParamsValues();
        assert.isUndefined(element.queryModel);
      });

      test('Updates query model values', () => {
        element.queryModel = [{name: 't1'}, {name: 't2'}];
        element._applyQueryParamsValues({
          t1: 'test1',
          t2: 'test2'
        });
        assert.equal(element.queryModel[0].value, 'test1');
        assert.equal(element.queryModel[1].value, 'test2');
      });

      test('Won\'t update value when updating the model', () => {
        element.queryModel = [{name: 't1'}, {name: 't2'}];
        const spy = sinon.spy(element, '_computeValue');
        element._applyQueryParamsValues({
          t1: 'test1',
          t2: 'test2'
        });
        assert.isFalse(spy.called);
      });

      test('Ignores non-existin items', () => {
        element.queryModel = [{name: 't1'}, {name: 't2'}];
        element._applyQueryParamsValues({
          t0: 'test1',
          t2: 'test2'
        });
        assert.isUndefined(element.queryModel[0].value);
        assert.equal(element.queryModel[1].value, 'test2');
      });
    });

    suite('_applyUriValues()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Does nothing when empty arguments ', () => {
        element._applyUriValues([], []);
        assert.isUndefined(element.pathModel);
      });

      test('Updates query model values', () => {
        element.pathModel = [{name: 't1'}, {name: 't2'}];
        element._applyUriValues(['test1', 'test2'], ['t1', 't2']);
        assert.equal(element.pathModel[0].value, 'test1');
        assert.equal(element.pathModel[1].value, 'test2');
      });

      test('Ignores non-existin items', () => {
        element.pathModel = [{name: 't1'}, {name: 't2'}];
        element._applyUriValues(['test1', 'test2'], ['t0', 't2']);
        assert.isUndefined(element.pathModel[0].value);
        assert.equal(element.pathModel[1].value, 'test2');
      });
    });

    suite('_applyQueryParamToObject()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Does nothin when no param argument', () => {
        const obj = {};
        element._applyQueryParamToObject(undefined, obj);
        assert.lengthOf(Object.keys(obj), 0);
      });

      test('Does nothin when no obj argument', () => {
        element._applyQueryParamToObject('a=b');
        // for test coverage, also, no error
      });

      test('Does nothin when no param is not a string', () => {
        const obj = {};
        element._applyQueryParamToObject(false, obj);
        assert.lengthOf(Object.keys(obj), 0);
      });

      test('Adds parameter to the object', () => {
        const obj = {};
        element._applyQueryParamToObject('a=b', obj);
        assert.lengthOf(Object.keys(obj), 1);
        assert.equal(obj.a, 'b');
      });

      test('Creates array value', () => {
        const obj = {
          a: 'b'
        };
        element._applyQueryParamToObject('a=c', obj);
        assert.deepEqual(obj.a, ['b', 'c']);
      });

      test('Appends to existin array', () => {
        const obj = {
          a: ['b', 'd']
        };
        element._applyQueryParamToObject('a=c', obj);
        assert.deepEqual(obj.a, ['b', 'd', 'c']);
      });
    });

    suite('_computeFullUrl()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('return default string', () => {
        const result = element._computeFullUrl();
        assert.equal(result, '/');
      });

      test('Adds slash to the beginning', () => {
        const result = element._computeFullUrl(null, 'test');
        assert.equal(result, '/test');
      });

      test('Creates full URL', () => {
        const result = element._computeFullUrl('https://domain.com', 'test');
        assert.equal(result, 'https://domain.com/test');
      });

      test('Removed trailing slash', () => {
        const result = element._computeFullUrl('https://domain.com/', 'test');
        assert.equal(result, 'https://domain.com/test');
      });
    });
    </script>
  </body>
</html>
